"""Programmatic Alembic autogenerate + upgrade helper.

Intended for development only. Controlled by the environment variable
AUTO_MIGRATE=1 (or true/yes). When enabled the helper will:
 - run `alembic revision --autogenerate -m "autogen: <timestamp>"`
 - inspect the generated migration; if it contains no operations it will be removed
 - otherwise run `alembic upgrade head`

This prevents empty migrations from accumulating and avoids running in prod.
"""
from __future__ import annotations

import os
import time
from alembic.config import Config
from alembic import command
from pathlib import Path
import re


def should_auto_migrate() -> bool:
    v = os.getenv("AUTO_MIGRATE", "").lower()
    if v in ("1", "true", "yes", "on"):  # explicit opt-in
        return True
    # also allow when running in obvious dev mode
    env = os.getenv("ENV", os.getenv("FLASK_ENV", "")).lower()
    return env in ("dev", "development")


def latest_version_file(versions_dir: Path) -> Path | None:
    files = sorted(versions_dir.glob("*.py"), key=lambda p: p.stat().st_mtime, reverse=True)
    return files[0] if files else None


def file_has_changes(path: Path) -> bool:
    text = path.read_text(encoding="utf8")
    # If the autogenerated body contains only 'pass' then no changes
    # Look for the Alembic marker and then a 'pass' in the upgrade() body
    m = re.search(r"def upgrade\(\):([\s\S]*?)def downgrade\(\):", text)
    if not m:
        # conservative: assume changes exist
        return True
    body = m.group(1)
    # if 'pass' is the only non-whitespace content, treat as no-op
    if re.search(r"^\s*pass\s*$", body, re.MULTILINE):
        return False
    return True


def ensure_revision_header(path: Path):
    text = path.read_text(encoding="utf8")
    if "revision" in text and "down_revision" in text:
        return

    # derive revision id from filename
    name = path.stem
    rev = name.split("_")[0]
    # try to find an existing down_revision from other files
    parent = path.parent
    down = None
    for f in sorted(parent.glob("*.py"), key=lambda p: p.stat().st_mtime, reverse=True):
        if f == path:
            continue
        txt = f.read_text(encoding="utf8")
        m = re.search(r"revision\s*=\s*'([^']+)'", txt)
        if m:
            down = m.group(1)
            break

    header = "# revision identifiers, used by Alembic.\n"
    header += f"revision = '{rev}'\n"
    header += (f"down_revision = '{down}'\n" if down else "down_revision = None\n")
    header += "branch_labels = None\ndepends_on = None\n\n"

    # insert header before imports (after any module docstring)
    if m := re.match(r"(\s*\"\"\"[\s\S]*?\"\"\")([\s\S]*)", text):
        new_text = m.group(1) + "\n" + header + m.group(2)
    else:
        new_text = header + text
    path.write_text(new_text, encoding="utf8")


def autogenerate_and_upgrade(alembic_ini: str = "alembic.ini") -> None:
    cfg = Config(alembic_ini)
    cfg.set_main_option("script_location", "alembic")

    versions_dir = Path(cfg.get_main_option("script_location") or "alembic") / "versions"
    versions_dir = Path(versions_dir)
    if not versions_dir.exists():
        versions_dir.mkdir(parents=True, exist_ok=True)

    # create a revision with autogenerate
    msg = f"autogen: {int(time.time())}"
    try:
        command.revision(cfg, message=msg, autogenerate=True)
    except Exception as e:
        # revision may fail; abort safely
        print("[auto_migrate] alembic revision failed:", e)
        return

    latest = latest_version_file(versions_dir)
    if not latest:
        print("[auto_migrate] no migration file generated")
        return

    # if file has no real changes, delete it and do nothing
    try:
        if not file_has_changes(latest):
            print(f"[auto_migrate] no schema changes detected; removing {latest.name}")
            latest.unlink()
            return
    except Exception as e:
        print("[auto_migrate] error inspecting generated file:", e)

    # ensure header exists
    try:
        ensure_revision_header(latest)
    except Exception as e:
        print("[auto_migrate] could not ensure revision header:", e)

    # run upgrade
    try:
        print(f"[auto_migrate] applying migration {latest.name}")
        command.upgrade(cfg, "head")
        print("[auto_migrate] upgrade head complete")
    except Exception as e:
        print("[auto_migrate] alembic upgrade failed:", e)


if __name__ == "__main__":
    if should_auto_migrate():
        autogenerate_and_upgrade()
    else:
        print("AUTO_MIGRATE not enabled; skipping")
